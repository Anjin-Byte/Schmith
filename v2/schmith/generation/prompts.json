{
  "instructions": [
    "Generate a C# Trimble XChange DataObject class based on the provided schema information.",
    "",
    "REQUIREMENTS:",
    "1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes",
    "2. Convert JSON field names to PascalCase for C# property names",
    "3. Add [Description] attributes using the field descriptions from the schema",
    "4. Mark required fields with [Required] attribute and use 'required' keyword",
    "5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)",
    "6. Use 'init' accessors for immutable data objects: { get; init; }",
    "7. Include a [PrimaryKey] attribute ONLY on the root DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. A PRIMARY KEY section in the schema provides the exact json_name and C# property name: use them to write [PrimaryKey(\"json_name\", nameof(CsharpPropertyName))].",
    "8. Primary key fields must be required and non-nullable. Override nullability for the primary key field: do NOT use [Nullable(true)] or a nullable type (?) on the primary key property.",
    "9. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName(\"<value>\")] to each enum member so serialized values match the schema.",
    "9a. If the schema itself IS an enum (has ENUM section with values but no FIELDS), generate a standalone enum WITHOUT wrapping it in a class. The enum should have [JsonConverter(typeof(JsonStringEnumConverter))] and each member should have [JsonStringEnumMemberName].",
    "10. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]",
    "11. Add XML summary comments for the class",
    "12. Use appropriate C# types:",
    "    - string for text",
    "    - int/long for integers",
    "    - double/decimal for numbers",
    "    - bool for booleans",
    "    - DateTime for datetime fields",
    "    - DateOnly for date-only fields",
    "",
    "DO NOT INCLUDE:",
    "- namespace declarations",
    "- using directives",
    "- stub or placeholder classes for nested types (they are generated separately)",
    "Start directly with the XML summary comment for the class.",
    "",
    "OUTPUT:",
    "Return ONLY the single C# class definition requested, no explanations or markdown.",
    "Do NOT generate multiple classes - only generate the one class specified in SCHEMA."
  ],
  "example_code": [
    "/// <summary>",
    "/// {Description}",
    "/// </summary>",
    "[PrimaryKey(\"id\", nameof(Id))]",
    "[Description(\"{Description}\")]",
    "public class {ClassName}",
    "{",
    "    [JsonPropertyName(\"id\")]",
    "    [Description(\"Unique identifier\")]",
    "    [Required]",
    "    public required string Id { get; init; }",
    "",
    "    [JsonPropertyName(\"name\")]",
    "    [Description(\"Display name\")]",
    "    [Nullable(true)]",
    "    public string? Name { get; init; }",
    "}"
  ]
}
