================================================================================
EmployeeDocumentFullDataObject (parent) page 1/4
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

PAGING NOTE:
- Include only the fields listed for this page.

============================================================
SCHEMA: EmployeeDocumentFullDataObject (EmployeeDocumentFull)
============================================================
API Name: ukg_v2_client
Schema ID: schema:definitions/EmployeeDocumentFull
Description: No description
Primary Key: Id
Namespace: Connector.ukg_v2_client.v1.EmployeeDocumentFull
Role: parent

PAGING:
  Page: 1 of 4
  Fields in this page: 6
  Total fields: 21
  All field names: employee_id, employee_external_id, document_type_id, title, date, organization_ids, metadata, external_reference, id, origin, origin_details, sender_id, name, trashed, expired, expiry_date, created_at, updated_at, code, value, label

NESTED TYPES: EmployeeDocumentComputedFieldsOrigin, EmployeeDocumentComputedFieldsOriginDetails, MetaDataBase
Use these class names for matching nested object fields in this schema.

FIELDS (this page):
----------------------------------------
  employee_id: string? [nullable]
    Description: `ID` of the Employee for whom the Document is uploaded. Mandatory if `external_employee_id` is not provided

  employee_external_id: string? [nullable]
    Description: External ID of the Employee for whom the Document is uploaded

  document_type_id: string [required]
    Description: Document Type ID, the document belongs to

  title: string? [nullable]
    Description: Title of the Document

  date: string? [nullable]
    Description: Date explicitly passed at the Document upload via the API. If available, it will be used instead of the creation date to sort the Document

  organization_ids: string[]? [nullable]
    Description: Organization IDs, inherited from the employee, the Document is attached to. When uploading a document, if this parameter is specified in the call, the document will be associated with all of the organizations passed. Note: the employee must belong to these organizations via an active or an inactive registration references. If this parameter is not specified, the document will be associated with all of the employee’s active organizations for current employees or with all of the employee’s inactive organizations for terminated employees


EXAMPLE CODE PATTERN:
----------------------------------------
/// <summary>
/// {Description}
/// </summary>
[PrimaryKey("id", nameof({PrimaryKeyProperty}))]
[Description("{Description}")]
public class {ClassName}
{
    [JsonPropertyName("id")]
    [Description("Unique identifier")]
    [Required]
    public required string Id { get; init; }

    [JsonPropertyName("name")]
    [Description("Display name")]
    [Nullable(true)]
    public string? Name { get; init; }
}

================================================================================
EmployeeDocumentFullDataObject (parent) page 2/4
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: fields_only
- Return ONLY the property blocks for this page.
- Do NOT include namespace, using statements, class declaration, or closing braces.
- Wrap properties with `// BEGIN_FIELDS` and `// END_FIELDS` markers.

============================================================
SCHEMA: EmployeeDocumentFullDataObject (EmployeeDocumentFull)
============================================================
API Name: ukg_v2_client
Schema ID: schema:definitions/EmployeeDocumentFull
Description: No description
Primary Key: Id
Namespace: Connector.ukg_v2_client.v1.EmployeeDocumentFull
Role: parent

PAGING:
  Page: 2 of 4
  Fields in this page: 5
  Total fields: 21
  All field names: employee_id, employee_external_id, document_type_id, title, date, organization_ids, metadata, external_reference, id, origin, origin_details, sender_id, name, trashed, expired, expiry_date, created_at, updated_at, code, value, label

NESTED TYPES: EmployeeDocumentComputedFieldsOrigin, EmployeeDocumentComputedFieldsOriginDetails, MetaDataBase
Use these class names for matching nested object fields in this schema.

FIELDS (this page):
----------------------------------------
  metadata: MetaDataBase[]? [nullable]

  external_reference: string? [nullable]
    Description: External document reference to help identify the Document in external tools or filing systems

  id: string [required]
    Description: ID of the Document

  origin: EmployeeDocumentComputedFieldsOrigin [required]
    Description: Origin of the Document
    Enum: api, distribution, doc_management, mass_mailing, signature, web
    Constraints: enum=['api', 'distribution', 'doc_management', 'mass_mailing', 'signature', 'web']

  origin_details: EmployeeDocumentComputedFieldsOriginDetails [required]
    Description: Depending on the origin of the document and when suitable, provides more details on its origin. Otherwise its value is set to null
    Enum: drop_in_vault, employee, mass_mailing, signature, user
    Constraints: enum=['drop_in_vault', 'employee', 'mass_mailing', 'signature', 'user']


EXAMPLE CODE PATTERN:
----------------------------------------
// BEGIN_FIELDS
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
// END_FIELDS

================================================================================
EmployeeDocumentFullDataObject (parent) page 3/4
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: fields_only
- Return ONLY the property blocks for this page.
- Do NOT include namespace, using statements, class declaration, or closing braces.
- Wrap properties with `// BEGIN_FIELDS` and `// END_FIELDS` markers.

============================================================
SCHEMA: EmployeeDocumentFullDataObject (EmployeeDocumentFull)
============================================================
API Name: ukg_v2_client
Schema ID: schema:definitions/EmployeeDocumentFull
Description: No description
Primary Key: Id
Namespace: Connector.ukg_v2_client.v1.EmployeeDocumentFull
Role: parent

PAGING:
  Page: 3 of 4
  Fields in this page: 5
  Total fields: 21
  All field names: employee_id, employee_external_id, document_type_id, title, date, organization_ids, metadata, external_reference, id, origin, origin_details, sender_id, name, trashed, expired, expiry_date, created_at, updated_at, code, value, label

NESTED TYPES: EmployeeDocumentComputedFieldsOrigin, EmployeeDocumentComputedFieldsOriginDetails, MetaDataBase
Use these class names for matching nested object fields in this schema.

FIELDS (this page):
----------------------------------------
  sender_id: string? [nullable]
    Description: ID of the user or employee who uploaded the document. Empty string if the user does not have an ID. Null if the user is unknown

  name: string [required]
    Description: Name of the Document

  trashed: bool [required]
    Description: Has the Document been trashed (true)? or not (false)

  expired: bool? [nullable]
    Description: Is the Document past retention period (true)? or not (false)

  expiry_date: string? [nullable]
    Description: End of retention period after which the Document will be marked as Past retention period


EXAMPLE CODE PATTERN:
----------------------------------------
// BEGIN_FIELDS
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
// END_FIELDS

================================================================================
EmployeeDocumentFullDataObject (parent) page 4/4
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: fields_only
- Return ONLY the property blocks for this page.
- Do NOT include namespace, using statements, class declaration, or closing braces.
- Wrap properties with `// BEGIN_FIELDS` and `// END_FIELDS` markers.

============================================================
SCHEMA: EmployeeDocumentFullDataObject (EmployeeDocumentFull)
============================================================
API Name: ukg_v2_client
Schema ID: schema:definitions/EmployeeDocumentFull
Description: No description
Primary Key: Id
Namespace: Connector.ukg_v2_client.v1.EmployeeDocumentFull
Role: parent

PAGING:
  Page: 4 of 4
  Fields in this page: 5
  Total fields: 21
  All field names: employee_id, employee_external_id, document_type_id, title, date, organization_ids, metadata, external_reference, id, origin, origin_details, sender_id, name, trashed, expired, expiry_date, created_at, updated_at, code, value, label

NESTED TYPES: EmployeeDocumentComputedFieldsOrigin, EmployeeDocumentComputedFieldsOriginDetails, MetaDataBase
Use these class names for matching nested object fields in this schema.

FIELDS (this page):
----------------------------------------
  created_at: string [required]

  updated_at: string [required]

  code: string [required]
    Description: Custom Field `ID`

  value: string [required]
    Description: Custom Field value

  label: string? [nullable]
    Description: Label of the custom field value


EXAMPLE CODE PATTERN:
----------------------------------------
// BEGIN_FIELDS
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
// END_FIELDS

================================================================================
EmployeeDocumentComputedFieldsOrigin (nested) page 1/1
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: class_only
- Return ONLY the class declaration for `EmployeeDocumentComputedFieldsOrigin`.
- Do NOT include namespace or using statements.
- Include only the fields listed for this page.

============================================================
SCHEMA: EmployeeDocumentComputedFieldsOrigin (EmployeeDocumentComputedFieldsOrigin)
============================================================
API Name: ukg_v2_client
Schema ID: schema:anon/da2408f83f2afd3b041ed3f588208b3d92fe7080
Description: Origin of the Document
Namespace: Connector.ukg_v2_client.v1.EmployeeDocumentFull
Role: nested

ENUM:
  Values: api, distribution, doc_management, mass_mailing, signature, web

PAGING:
  Page: 1 of 1
  Fields in this page: 0
  Total fields: 0
  All field names: 

PARENT CONTEXT:
  Parent Class: EmployeeDocumentFullDataObject
  Parent Description: No description
  Parent Field Count: 21
  Parent Field Names: employee_id, employee_external_id, document_type_id, title, date, organization_ids, metadata, external_reference, id, origin, origin_details, sender_id, name, trashed, expired, expiry_date, created_at, updated_at, code, value, label
  Parent Nested Types: EmployeeDocumentComputedFieldsOrigin, EmployeeDocumentComputedFieldsOriginDetails, MetaDataBase

FIELDS (this page):
----------------------------------------

EXAMPLE CODE PATTERN:
----------------------------------------
public class EmployeeDocumentComputedFieldsOrigin
{
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
}

================================================================================
EmployeeDocumentComputedFieldsOriginDetails (nested) page 1/1
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: class_only
- Return ONLY the class declaration for `EmployeeDocumentComputedFieldsOriginDetails`.
- Do NOT include namespace or using statements.
- Include only the fields listed for this page.

============================================================
SCHEMA: EmployeeDocumentComputedFieldsOriginDetails (EmployeeDocumentComputedFieldsOriginDetails)
============================================================
API Name: ukg_v2_client
Schema ID: schema:anon/8431fe4a00b2656a6bbf17e3bdb1b278a8abec19
Description: Depending on the origin of the document and when suitable, provides more details on its origin. Otherwise its value is set to null
Namespace: Connector.ukg_v2_client.v1.EmployeeDocumentFull
Role: nested

ENUM:
  Values: drop_in_vault, employee, mass_mailing, signature, user

PAGING:
  Page: 1 of 1
  Fields in this page: 0
  Total fields: 0
  All field names: 

PARENT CONTEXT:
  Parent Class: EmployeeDocumentFullDataObject
  Parent Description: No description
  Parent Field Count: 21
  Parent Field Names: employee_id, employee_external_id, document_type_id, title, date, organization_ids, metadata, external_reference, id, origin, origin_details, sender_id, name, trashed, expired, expiry_date, created_at, updated_at, code, value, label
  Parent Nested Types: EmployeeDocumentComputedFieldsOrigin, EmployeeDocumentComputedFieldsOriginDetails, MetaDataBase

FIELDS (this page):
----------------------------------------

EXAMPLE CODE PATTERN:
----------------------------------------
public class EmployeeDocumentComputedFieldsOriginDetails
{
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
}

================================================================================
MetaDataBase (nested) page 1/1
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: class_only
- Return ONLY the class declaration for `MetaDataBase`.
- Do NOT include namespace or using statements.
- Include only the fields listed for this page.

============================================================
SCHEMA: MetaDataBase (MetaDataBase)
============================================================
API Name: ukg_v2_client
Schema ID: schema:definitions/MetaDataBase
Description: No description
Namespace: Connector.ukg_v2_client.v1.EmployeeDocumentFull
Role: nested

PAGING:
  Page: 1 of 1
  Fields in this page: 2
  Total fields: 2
  All field names: code, value

PARENT CONTEXT:
  Parent Class: EmployeeDocumentFullDataObject
  Parent Description: No description
  Parent Field Count: 21
  Parent Field Names: employee_id, employee_external_id, document_type_id, title, date, organization_ids, metadata, external_reference, id, origin, origin_details, sender_id, name, trashed, expired, expiry_date, created_at, updated_at, code, value, label
  Parent Nested Types: EmployeeDocumentComputedFieldsOrigin, EmployeeDocumentComputedFieldsOriginDetails, MetaDataBase

FIELDS (this page):
----------------------------------------
  code: string [required]

  value: string [required]
    Description: The type depends on the type of the metadata. Can be one of integer, string or boolean.


EXAMPLE CODE PATTERN:
----------------------------------------
public class MetaDataBase
{
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
}
