================================================================================
SignerFullDataObject (parent) page 1/4
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

PAGING NOTE:
- Include only the fields listed for this page.

============================================================
SCHEMA: SignerFullDataObject (SignerFull)
============================================================
API Name: ukg_v2_client
Schema ID: schema:definitions/SignerFull
Description: No description
Primary Key: Id
Namespace: Connector.ukg_v2_client.v1.SignerFull
Role: parent

PAGING:
  Page: 1 of 4
  Fields in this page: 5
  Total fields: 20
  All field names: type, signature_positions, user_id, employee_id, first_name, last_name, language, email_address, mobile_phone_number, signature_process_id, signing_order, access_code, sms_notification, two_factor_auth, message, send_signed_document, signing_url, id, signed_at, state

NESTED TYPES: SignaturePosition, SignaturePositionUnitItem, SignerBaseType, SignerState, TwoFactorAuthenticationMethod
Use these class names for matching nested object fields in this schema.

FIELDS (this page):
----------------------------------------
  type: SignerBaseType? [nullable]
    Description: Type of the signer
- `organization`: this type represents the delegation seal. If the signature type has delegation activated, exactly one signer of this type must be defined on the signature process, otherwise this type is not allowed. This will materialize the position of the seal in the signed document
- `user`: the signer is a user
- `employee`: the signer is an employee already registered in the HRIS
- `external`: the signer can be anyone with a valid e-mail address
    Enum: organization, user, employee, external
    Constraints: enum=['organization', 'user', 'employee', 'external']

  signature_positions: SignaturePosition[]? [nullable]
    Description: This attribute is only used with Protect & Sign

  user_id: string? [nullable]
    Description: ID of the signer user, mandatory if the signer type is `user`, unused otherwise

  employee_id: string? [nullable]
    Description: ID of the signer employee, mandatory if the signer type is `employee`, unused otherwise

  first_name: string [required]
    Description: First name of the signer. Only mandatory when `type` is `external`
    Constraints: maxLength=70


EXAMPLE CODE PATTERN:
----------------------------------------
/// <summary>
/// {Description}
/// </summary>
[PrimaryKey("id", nameof({PrimaryKeyProperty}))]
[Description("{Description}")]
public class {ClassName}
{
    [JsonPropertyName("id")]
    [Description("Unique identifier")]
    [Required]
    public required string Id { get; init; }

    [JsonPropertyName("name")]
    [Description("Display name")]
    [Nullable(true)]
    public string? Name { get; init; }
}

================================================================================
SignerFullDataObject (parent) page 2/4
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: fields_only
- Return ONLY the property blocks for this page.
- Do NOT include namespace, using statements, class declaration, or closing braces.
- Wrap properties with `// BEGIN_FIELDS` and `// END_FIELDS` markers.

============================================================
SCHEMA: SignerFullDataObject (SignerFull)
============================================================
API Name: ukg_v2_client
Schema ID: schema:definitions/SignerFull
Description: No description
Primary Key: Id
Namespace: Connector.ukg_v2_client.v1.SignerFull
Role: parent

PAGING:
  Page: 2 of 4
  Fields in this page: 5
  Total fields: 20
  All field names: type, signature_positions, user_id, employee_id, first_name, last_name, language, email_address, mobile_phone_number, signature_process_id, signing_order, access_code, sms_notification, two_factor_auth, message, send_signed_document, signing_url, id, signed_at, state

NESTED TYPES: SignaturePosition, SignaturePositionUnitItem, SignerBaseType, SignerState, TwoFactorAuthenticationMethod
Use these class names for matching nested object fields in this schema.

FIELDS (this page):
----------------------------------------
  last_name: string [required]
    Description: Last name of the signer. Only mandatory when `type` is `external`
    Constraints: maxLength=70

  language: string? [nullable]
    Description: Language of the signer. Used only when `type` is `external`

  email_address: string? [nullable]
    Description: Email address used for the signature process. Only mandatory when `type` is `external`. If the email address is not indicated and the `type` is `employee` or `user`, the email address registered under the user or employeeâ€™s profile will be used
    Constraints: maxLength=254

  mobile_phone_number: string? [nullable]
    Description: Mobile phone number used for the signature process
    Constraints: maxLength=50

  signature_process_id: string [required]
    Description: ID of the signature process


EXAMPLE CODE PATTERN:
----------------------------------------
// BEGIN_FIELDS
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
// END_FIELDS

================================================================================
SignerFullDataObject (parent) page 3/4
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: fields_only
- Return ONLY the property blocks for this page.
- Do NOT include namespace, using statements, class declaration, or closing braces.
- Wrap properties with `// BEGIN_FIELDS` and `// END_FIELDS` markers.

============================================================
SCHEMA: SignerFullDataObject (SignerFull)
============================================================
API Name: ukg_v2_client
Schema ID: schema:definitions/SignerFull
Description: No description
Primary Key: Id
Namespace: Connector.ukg_v2_client.v1.SignerFull
Role: parent

PAGING:
  Page: 3 of 4
  Fields in this page: 5
  Total fields: 20
  All field names: type, signature_positions, user_id, employee_id, first_name, last_name, language, email_address, mobile_phone_number, signature_process_id, signing_order, access_code, sms_notification, two_factor_auth, message, send_signed_document, signing_url, id, signed_at, state

NESTED TYPES: SignaturePosition, SignaturePositionUnitItem, SignerBaseType, SignerState, TwoFactorAuthenticationMethod
Use these class names for matching nested object fields in this schema.

FIELDS (this page):
----------------------------------------
  signing_order: int? [nullable]
    Description: The signers will be assigned in the order defined by this parameter

  access_code: string? [nullable]
    Description: Access code to use by the signer when `external_authentication` is enabled on the signature type.

  sms_notification: bool? [nullable]
    Description: Enable text notification for this signer

  two_factor_auth: TwoFactorAuthenticationMethod? [nullable]
    Description: Two factor authentication methods to use for this signer

  message: string? [nullable]
    Description: Personal message that will be sent to the signer
    Constraints: maxLength=550


EXAMPLE CODE PATTERN:
----------------------------------------
// BEGIN_FIELDS
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
// END_FIELDS

================================================================================
SignerFullDataObject (parent) page 4/4
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: fields_only
- Return ONLY the property blocks for this page.
- Do NOT include namespace, using statements, class declaration, or closing braces.
- Wrap properties with `// BEGIN_FIELDS` and `// END_FIELDS` markers.

============================================================
SCHEMA: SignerFullDataObject (SignerFull)
============================================================
API Name: ukg_v2_client
Schema ID: schema:definitions/SignerFull
Description: No description
Primary Key: Id
Namespace: Connector.ukg_v2_client.v1.SignerFull
Role: parent

PAGING:
  Page: 4 of 4
  Fields in this page: 5
  Total fields: 20
  All field names: type, signature_positions, user_id, employee_id, first_name, last_name, language, email_address, mobile_phone_number, signature_process_id, signing_order, access_code, sms_notification, two_factor_auth, message, send_signed_document, signing_url, id, signed_at, state

NESTED TYPES: SignaturePosition, SignaturePositionUnitItem, SignerBaseType, SignerState, TwoFactorAuthenticationMethod
Use these class names for matching nested object fields in this schema.

FIELDS (this page):
----------------------------------------
  send_signed_document: bool? [nullable]
    Description: Send the signed document to the signer once it's signed by all signers. Only used when the `type` is `user`

  signing_url: string? [nullable]
    Description: Signing URL for this signer, only available when `include_signer_link` is enabled on the signature type and if the state of the signer is `in_progress`

  id: string? [nullable]
    Description: ID of the signer

  signed_at: string? [nullable, read-only]
    Description: Timestamp by which the signer has signed the document

  state: SignerState? [nullable]
    Enum: pending, in_progress, signed, rejected, error, done, delivered, delayed


EXAMPLE CODE PATTERN:
----------------------------------------
// BEGIN_FIELDS
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
// END_FIELDS

================================================================================
SignaturePosition (nested) page 1/1
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: class_only
- Return ONLY the class declaration for `SignaturePosition`.
- Do NOT include namespace or using statements.
- Include only the fields listed for this page.

============================================================
SCHEMA: SignaturePosition (SignaturePosition)
============================================================
API Name: ukg_v2_client
Schema ID: schema:definitions/SignaturePosition
Description: No description
Namespace: Connector.ukg_v2_client.v1.SignerFull
Role: nested

PAGING:
  Page: 1 of 1
  Fields in this page: 6
  Total fields: 6
  All field names: page, unit, x, y, width, height

PARENT CONTEXT:
  Parent Class: SignerFullDataObject
  Parent Description: No description
  Parent Field Count: 20
  Parent Field Names: type, signature_positions, user_id, employee_id, first_name, last_name, language, email_address, mobile_phone_number, signature_process_id, signing_order, access_code, sms_notification, two_factor_auth, message, send_signed_document, signing_url, id, signed_at, state
  Parent Nested Types: SignaturePosition, SignaturePositionUnitItem, SignerBaseType, SignerState, TwoFactorAuthenticationMethod

FIELDS (this page):
----------------------------------------
  page: int? [nullable]
    Description: Page of the document where the signature field will be displayed

  unit: SignaturePositionUnitItem? [nullable]
    Description: Specifies the unit used for the `x`, `y`, `width` and `height` attributes
When the server sends the resource, the unit is always `pt`
    Enum: cm, inch, pt
    Constraints: enum=['cm', 'inch', 'pt']

  x: double? [nullable]
    Description: Distance between the left edge of the document and the left border of the signer's seal

  y: double? [nullable]
    Description: Distance between the bottom edge of the document and the bottom edge of the signer's seal

  width: double? [nullable]
    Description: Width of the signer's seal

  height: double? [nullable]
    Description: Height of the signer's seal


EXAMPLE CODE PATTERN:
----------------------------------------
public class SignaturePosition
{
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
}

================================================================================
SignaturePositionUnitItem (nested) page 1/1
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: class_only
- Return ONLY the class declaration for `SignaturePositionUnitItem`.
- Do NOT include namespace or using statements.
- Include only the fields listed for this page.

============================================================
SCHEMA: SignaturePositionUnitItem (SignaturePositionUnitItem)
============================================================
API Name: ukg_v2_client
Schema ID: schema:anon/27002a2e7ea816d4d0cae24173ff27461c6937e0
Description: Specifies the unit used for the `x`, `y`, `width` and `height` attributes
When the server sends the resource, the unit is always `pt`

Namespace: Connector.ukg_v2_client.v1.SignerFull
Role: nested

ENUM:
  Values: cm, inch, pt

PAGING:
  Page: 1 of 1
  Fields in this page: 0
  Total fields: 0
  All field names: 

PARENT CONTEXT:
  Parent Class: SignerFullDataObject
  Parent Description: No description
  Parent Field Count: 20
  Parent Field Names: type, signature_positions, user_id, employee_id, first_name, last_name, language, email_address, mobile_phone_number, signature_process_id, signing_order, access_code, sms_notification, two_factor_auth, message, send_signed_document, signing_url, id, signed_at, state
  Parent Nested Types: SignaturePosition, SignaturePositionUnitItem, SignerBaseType, SignerState, TwoFactorAuthenticationMethod

FIELDS (this page):
----------------------------------------

EXAMPLE CODE PATTERN:
----------------------------------------
public class SignaturePositionUnitItem
{
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
}

================================================================================
SignerBaseType (nested) page 1/1
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: class_only
- Return ONLY the class declaration for `SignerBaseType`.
- Do NOT include namespace or using statements.
- Include only the fields listed for this page.

============================================================
SCHEMA: SignerBaseType (SignerBaseType)
============================================================
API Name: ukg_v2_client
Schema ID: schema:anon/2b360fd31e8c89122e3db638daa1ac4b28b81830
Description: Type of the signer
- `organization`: this type represents the delegation seal. If the signature type has delegation activated, exactly one signer of this type must be defined on the signature process, otherwise this type is not allowed. This will materialize the position of the seal in the signed document
- `user`: the signer is a user
- `employee`: the signer is an employee already registered in the HRIS
- `external`: the signer can be anyone with a valid e-mail address

Namespace: Connector.ukg_v2_client.v1.SignerFull
Role: nested

ENUM:
  Values: organization, user, employee, external

PAGING:
  Page: 1 of 1
  Fields in this page: 0
  Total fields: 0
  All field names: 

PARENT CONTEXT:
  Parent Class: SignerFullDataObject
  Parent Description: No description
  Parent Field Count: 20
  Parent Field Names: type, signature_positions, user_id, employee_id, first_name, last_name, language, email_address, mobile_phone_number, signature_process_id, signing_order, access_code, sms_notification, two_factor_auth, message, send_signed_document, signing_url, id, signed_at, state
  Parent Nested Types: SignaturePosition, SignaturePositionUnitItem, SignerBaseType, SignerState, TwoFactorAuthenticationMethod

FIELDS (this page):
----------------------------------------

EXAMPLE CODE PATTERN:
----------------------------------------
public class SignerBaseType
{
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
}

================================================================================
SignerState (nested) page 1/1
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: class_only
- Return ONLY the class declaration for `SignerState`.
- Do NOT include namespace or using statements.
- Include only the fields listed for this page.

============================================================
SCHEMA: SignerState (SignerState)
============================================================
API Name: ukg_v2_client
Schema ID: schema:definitions/SignerState
Description: Completion state of this signer's step in the signature process

- `pending`: The signer is not requested to sign yet
- `in_progress`: The signer is requested to sign (or reject) the signature process
- `signed`: The signer has signed the signature process
- `rejected`: The signer has rejected the signature process
- `error`: There has been an error during the signature process. Please contact the support
- `done`: Only used for signers with type `organization` after the delegation seal has been applied
- `id_check_failed`: The signer has failed the identity verification process
- `delivered`: The signer has viewed the document on the DocuSign signing web site. Only applies to DocuSign QES signatures.
- `delayed`: The signer has selected to finish the signing process at a later time. Only applies to DocuSign QES signatures.

Namespace: Connector.ukg_v2_client.v1.SignerFull
Role: nested

ENUM:
  Values: pending, in_progress, signed, rejected, error, done, delivered, delayed

PAGING:
  Page: 1 of 1
  Fields in this page: 0
  Total fields: 0
  All field names: 

PARENT CONTEXT:
  Parent Class: SignerFullDataObject
  Parent Description: No description
  Parent Field Count: 20
  Parent Field Names: type, signature_positions, user_id, employee_id, first_name, last_name, language, email_address, mobile_phone_number, signature_process_id, signing_order, access_code, sms_notification, two_factor_auth, message, send_signed_document, signing_url, id, signed_at, state
  Parent Nested Types: SignaturePosition, SignaturePositionUnitItem, SignerBaseType, SignerState, TwoFactorAuthenticationMethod

FIELDS (this page):
----------------------------------------

EXAMPLE CODE PATTERN:
----------------------------------------
public class SignerState
{
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
}

================================================================================
TwoFactorAuthenticationMethod (nested) page 1/1
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: class_only
- Return ONLY the class declaration for `TwoFactorAuthenticationMethod`.
- Do NOT include namespace or using statements.
- Include only the fields listed for this page.

============================================================
SCHEMA: TwoFactorAuthenticationMethod (TwoFactorAuthenticationMethod)
============================================================
API Name: ukg_v2_client
Schema ID: schema:definitions/TwoFactorAuthenticationMethod
Description: No description
Namespace: Connector.ukg_v2_client.v1.SignerFull
Role: nested

PAGING:
  Page: 1 of 1
  Fields in this page: 2
  Total fields: 2
  All field names: sms, email

PARENT CONTEXT:
  Parent Class: SignerFullDataObject
  Parent Description: No description
  Parent Field Count: 20
  Parent Field Names: type, signature_positions, user_id, employee_id, first_name, last_name, language, email_address, mobile_phone_number, signature_process_id, signing_order, access_code, sms_notification, two_factor_auth, message, send_signed_document, signing_url, id, signed_at, state
  Parent Nested Types: SignaturePosition, SignaturePositionUnitItem, SignerBaseType, SignerState, TwoFactorAuthenticationMethod

FIELDS (this page):
----------------------------------------
  sms: bool? [nullable]
    Description: Enable two factor authentication by text message for this signer

  email: bool? [nullable]
    Description: Enable two factor authentication by email for this signer


EXAMPLE CODE PATTERN:
----------------------------------------
public class TwoFactorAuthenticationMethod
{
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
}
