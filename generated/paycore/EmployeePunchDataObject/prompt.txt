================================================================================
EmployeePunchDataObject (parent) page 1/2
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

PAGING NOTE:
- Include only the fields listed for this page.

============================================================
SCHEMA: EmployeePunchDataObject (EmployeePunch)
============================================================
API Name: paycore
Schema ID: schema:components/EmployeePunch
Description: No description
Namespace: Connector.paycore.v1.EmployeePunch
Role: parent

PAGING:
  Page: 1 of 2
  Fields in this page: 5
  Total fields: 9
  All field names: employeeId, departmentId, punchDateTime, punchStatusType, activityTypeId, isTransfer, note, laborCodes, workLocationId

NESTED TYPES: LaborCode3, PunchStatusType
Use these class names for matching nested object fields in this schema.

FIELDS (this page):
----------------------------------------
  employeeId: string [required]
    Description: Unique Identifier of the Employee in Paycor's system. Generated by Paycor.

  departmentId: string [required]
    Description: Unique identifier of the department in Paycor's system. Generated by Paycor.

  punchDateTime: string [required]
    Description: Punch DateTime of the Employee. This is local time of the associated employee.
Format: YYYY-MM-DDTHH:MM:SS

  punchStatusType: PunchStatusType [required]
    Description: Enumeration of valid Punch Status Type values.
    Enum: Auto, In, Out, Transfer
    Enum Names: Auto, In, Out, Transfer

  activityTypeId: string [required]
    Description: Unique identifier for the Activity Type.


EXAMPLE CODE PATTERN:
----------------------------------------
/// <summary>
/// {Description}
/// </summary>
[PrimaryKey("id", nameof({PrimaryKeyProperty}))]
[Description("{Description}")]
public class {ClassName}
{
    [JsonPropertyName("id")]
    [Description("Unique identifier")]
    [Required]
    public required string Id { get; init; }

    [JsonPropertyName("name")]
    [Description("Display name")]
    [Nullable(true)]
    public string? Name { get; init; }
}

================================================================================
EmployeePunchDataObject (parent) page 2/2
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: fields_only
- Return ONLY the property blocks for this page.
- Do NOT include namespace, using statements, class declaration, or closing braces.
- Wrap properties with `// BEGIN_FIELDS` and `// END_FIELDS` markers.

============================================================
SCHEMA: EmployeePunchDataObject (EmployeePunch)
============================================================
API Name: paycore
Schema ID: schema:components/EmployeePunch
Description: No description
Namespace: Connector.paycore.v1.EmployeePunch
Role: parent

PAGING:
  Page: 2 of 2
  Fields in this page: 4
  Total fields: 9
  All field names: employeeId, departmentId, punchDateTime, punchStatusType, activityTypeId, isTransfer, note, laborCodes, workLocationId

NESTED TYPES: LaborCode3, PunchStatusType
Use these class names for matching nested object fields in this schema.

FIELDS (this page):
----------------------------------------
  isTransfer: bool [required]
    Description: IsTransfer property serves as an indicator in identifying a transfer punch.
When set to 'true' this property designates a punch as a transfer punch.
To appropriately handle a transfer punch ensure that the 'PunchStatusType' is set to value 'Transfer' when sending a payload.
If 'PunchStatusType' is set to a value other then 'Transfer' and 'IsTransfer' is set to 'true', PunchStatusType value will get ignored in most of the cases.
Transfer punch is essential for tracking and management of employee transfers during the working hours.
Transfer punches find their use in scenarios where an employee undergoes a change in department or labor type.
By adding a transfer punch the application effectively captures these transitions
providing an overview of employee movements between different departments or labor types.

  note: string? [nullable]
    Description: Comments to describe the Punch.
​Note when provided must be between 1 and 300 characters.

  laborCodes: LaborCode3[]? [nullable]
    Description: ​LaborCodes must either be empty or contain an array of valid LaborCategoryIds and LaborCodeIds.

  workLocationId: string? [nullable]
    Description: Unique identifier of the work location in Paycor's system. Generated by Paycor.


EXAMPLE CODE PATTERN:
----------------------------------------
// BEGIN_FIELDS
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
// END_FIELDS

================================================================================
LaborCode3 (nested) page 1/1
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: class_only
- Return ONLY the class declaration for `LaborCode3`.
- Do NOT include namespace or using statements.
- Include only the fields listed for this page.

============================================================
SCHEMA: LaborCode3 (LaborCode3)
============================================================
API Name: paycore
Schema ID: schema:components/LaborCode3
Description: No description
Namespace: Connector.paycore.v1.EmployeePunch
Role: nested

PAGING:
  Page: 1 of 1
  Fields in this page: 2
  Total fields: 2
  All field names: laborCategoryId, laborCodeId

PARENT CONTEXT:
  Parent Class: EmployeePunchDataObject
  Parent Description: No description
  Parent Field Count: 9
  Parent Field Names: employeeId, departmentId, punchDateTime, punchStatusType, activityTypeId, isTransfer, note, laborCodes, workLocationId
  Parent Nested Types: LaborCode3, PunchStatusType

FIELDS (this page):
----------------------------------------
  laborCategoryId: string? [nullable]
    Description: Unique identifier of the Job Costing Labor Category of the Labor Code.

  laborCodeId: string? [nullable]
    Description: Unique identifier for the Labor Code under the Labor Category.


EXAMPLE CODE PATTERN:
----------------------------------------
public class LaborCode3
{
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
}

================================================================================
PunchStatusType (nested) page 1/1
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: class_only
- Return ONLY the class declaration for `PunchStatusType`.
- Do NOT include namespace or using statements.
- Include only the fields listed for this page.

============================================================
SCHEMA: PunchStatusType (PunchStatusType)
============================================================
API Name: paycore
Schema ID: schema:components/PunchStatusType
Description: Enumeration of Valid Type of Status values. Default value is 'Auto'. If not provided, the system will default to 'Auto'.
Namespace: Connector.paycore.v1.EmployeePunch
Role: nested

ENUM:
  Values: Auto, In, Out, Transfer
  Names: Auto, In, Out, Transfer

PAGING:
  Page: 1 of 1
  Fields in this page: 0
  Total fields: 0
  All field names: 

PARENT CONTEXT:
  Parent Class: EmployeePunchDataObject
  Parent Description: No description
  Parent Field Count: 9
  Parent Field Names: employeeId, departmentId, punchDateTime, punchStatusType, activityTypeId, isTransfer, note, laborCodes, workLocationId
  Parent Nested Types: LaborCode3, PunchStatusType

FIELDS (this page):
----------------------------------------

EXAMPLE CODE PATTERN:
----------------------------------------
public class PunchStatusType
{
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
}
