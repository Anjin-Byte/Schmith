================================================================================
EstimateDataObject (parent) page 1/10
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

PAGING NOTE:
- Include only the fields listed for this page.

============================================================
SCHEMA: EstimateDataObject (Estimate)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.Estimate
Description: An estimate's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: parent

PAGING:
  Page: 1 of 10
  Fields in this page: 6
  Total fields: 56
  All field names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags

NESTED TYPES: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder
Use these class names for matching nested object fields in this schema.

FIELDS (this page):
----------------------------------------
  id: int? [nullable]
    Description: The estimate's identifier.

  number: string? [nullable]
    Description: The estimate's number.

  description: string? [nullable]
    Description: The estimate's description.

  tech_notes: string? [nullable]
    Description: The estimate's tech notes.

  customer_payment_terms: string? [nullable]
    Description: The estimate's customer payment terms.

  payment_status: string? [nullable]
    Description: The estimate's payment status.


EXAMPLE CODE PATTERN:
----------------------------------------
/// <summary>
/// {Description}
/// </summary>
[PrimaryKey("id", nameof({PrimaryKeyProperty}))]
[Description("{Description}")]
public class {ClassName}
{
    [JsonPropertyName("id")]
    [Description("Unique identifier")]
    [Required]
    public required string Id { get; init; }

    [JsonPropertyName("name")]
    [Description("Display name")]
    [Nullable(true)]
    public string? Name { get; init; }
}

================================================================================
EstimateDataObject (parent) page 2/10
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: fields_only
- Return ONLY the property blocks for this page.
- Do NOT include namespace, using statements, class declaration, or closing braces.
- Wrap properties with `// BEGIN_FIELDS` and `// END_FIELDS` markers.

============================================================
SCHEMA: EstimateDataObject (Estimate)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.Estimate
Description: An estimate's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: parent

PAGING:
  Page: 2 of 10
  Fields in this page: 6
  Total fields: 56
  All field names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags

NESTED TYPES: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder
Use these class names for matching nested object fields in this schema.

FIELDS (this page):
----------------------------------------
  taxes_fees_total: double? [nullable]
    Description: The estimate's taxes and fees total.

  total: double? [nullable]
    Description: The estimate's total.

  due_total: double? [nullable]
    Description: The estimate's due total.

  cost_total: double? [nullable]
    Description: The estimate's cost total.

  duration: int? [nullable]
    Description: The estimate's duration (in seconds).

  time_frame_promised_start: string? [nullable]
    Description: The estimate's time frame promised start.


EXAMPLE CODE PATTERN:
----------------------------------------
// BEGIN_FIELDS
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
// END_FIELDS

================================================================================
EstimateDataObject (parent) page 3/10
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: fields_only
- Return ONLY the property blocks for this page.
- Do NOT include namespace, using statements, class declaration, or closing braces.
- Wrap properties with `// BEGIN_FIELDS` and `// END_FIELDS` markers.

============================================================
SCHEMA: EstimateDataObject (Estimate)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.Estimate
Description: An estimate's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: parent

PAGING:
  Page: 3 of 10
  Fields in this page: 6
  Total fields: 56
  All field names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags

NESTED TYPES: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder
Use these class names for matching nested object fields in this schema.

FIELDS (this page):
----------------------------------------
  time_frame_promised_end: string? [nullable]
    Description: The estimate's time frame promised end.

  start_date: DateTime? [nullable]
    Description: The estimate's start date.

  created_at: DateTime? [nullable]
    Description: The estimate's created date.

  updated_at: DateTime? [nullable]
    Description: The estimate's updated date.

  customer_id: int? [nullable]
    Description: The `id` of attached customer to the estimate (Note: `id` - [integer] the customer's identifier).

  customer_name: string? [nullable]
    Description: The `header` of attached customer to the estimate (Note: `header` - [string] the customer's fields concatenated by pattern `{customer_name}`).


EXAMPLE CODE PATTERN:
----------------------------------------
// BEGIN_FIELDS
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
// END_FIELDS

================================================================================
EstimateDataObject (parent) page 4/10
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: fields_only
- Return ONLY the property blocks for this page.
- Do NOT include namespace, using statements, class declaration, or closing braces.
- Wrap properties with `// BEGIN_FIELDS` and `// END_FIELDS` markers.

============================================================
SCHEMA: EstimateDataObject (Estimate)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.Estimate
Description: An estimate's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: parent

PAGING:
  Page: 4 of 10
  Fields in this page: 6
  Total fields: 56
  All field names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags

NESTED TYPES: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder
Use these class names for matching nested object fields in this schema.

FIELDS (this page):
----------------------------------------
  parent_customer: string? [nullable]
    Description: The `header` of attached parent customer to the estimate (Note: `header` - [string] the parent customer's fields concatenated by pattern `{customer_name}`).

  status: string? [nullable]
    Description: The `header` of attached status to the estimate (Note: `header` - [string] the status'es fields concatenated by pattern `{name}`).

  sub_status: string? [nullable]
    Description: The `header` of attached sub status to the estimate (Note: `header` - [string] the sub status's fields concatenated by pattern `{name}`).

  contact_first_name: string? [nullable]
    Description: The estimate's contact first name.

  contact_last_name: string? [nullable]
    Description: The estimate's contact last name.

  street_1: string? [nullable]
    Description: The estimate's location street 1.


EXAMPLE CODE PATTERN:
----------------------------------------
// BEGIN_FIELDS
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
// END_FIELDS

================================================================================
EstimateDataObject (parent) page 5/10
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: fields_only
- Return ONLY the property blocks for this page.
- Do NOT include namespace, using statements, class declaration, or closing braces.
- Wrap properties with `// BEGIN_FIELDS` and `// END_FIELDS` markers.

============================================================
SCHEMA: EstimateDataObject (Estimate)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.Estimate
Description: An estimate's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: parent

PAGING:
  Page: 5 of 10
  Fields in this page: 6
  Total fields: 56
  All field names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags

NESTED TYPES: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder
Use these class names for matching nested object fields in this schema.

FIELDS (this page):
----------------------------------------
  street_2: string? [nullable]
    Description: The estimate's location street 2.

  city: string? [nullable]
    Description: The estimate's location city.

  state_prov: string? [nullable]
    Description: The estimate's location state prov.

  postal_code: string? [nullable]
    Description: The estimate's location postal code.

  location_name: string? [nullable]
    Description: The estimate's location name.

  is_gated: bool? [nullable]
    Description: The estimate's location is gated flag.


EXAMPLE CODE PATTERN:
----------------------------------------
// BEGIN_FIELDS
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
// END_FIELDS

================================================================================
EstimateDataObject (parent) page 6/10
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: fields_only
- Return ONLY the property blocks for this page.
- Do NOT include namespace, using statements, class declaration, or closing braces.
- Wrap properties with `// BEGIN_FIELDS` and `// END_FIELDS` markers.

============================================================
SCHEMA: EstimateDataObject (Estimate)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.Estimate
Description: An estimate's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: parent

PAGING:
  Page: 6 of 10
  Fields in this page: 6
  Total fields: 56
  All field names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags

NESTED TYPES: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder
Use these class names for matching nested object fields in this schema.

FIELDS (this page):
----------------------------------------
  gate_instructions: string? [nullable]
    Description: The estimate's location gate instructions.

  category: string? [nullable]
    Description: The `header` of attached category to the estimate (Note: `header` - [string] the category's fields concatenated by pattern `{category}`).

  source: string? [nullable]
    Description: The `header` of attached source to the estimate (Note: `header` - [string] the source's fields concatenated by pattern `{short_name}`).

  payment_type: string? [nullable]
    Description: The `header` of attached payment type to the estimate (Note: `header` - [string] the payment type's fields concatenated by pattern `{short_name}`).

  project: string? [nullable]
    Description: The `header` of attached project to the estimate (Note: `header` - [string] the project's fields concatenated by pattern `{name}`).

  phase: string? [nullable]
    Description: The `header` of attached phase to the estimate (Note: `header` - [string] the phase's fields concatenated by pattern `{name}`).


EXAMPLE CODE PATTERN:
----------------------------------------
// BEGIN_FIELDS
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
// END_FIELDS

================================================================================
EstimateDataObject (parent) page 7/10
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: fields_only
- Return ONLY the property blocks for this page.
- Do NOT include namespace, using statements, class declaration, or closing braces.
- Wrap properties with `// BEGIN_FIELDS` and `// END_FIELDS` markers.

============================================================
SCHEMA: EstimateDataObject (Estimate)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.Estimate
Description: An estimate's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: parent

PAGING:
  Page: 7 of 10
  Fields in this page: 5
  Total fields: 56
  All field names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags

NESTED TYPES: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder
Use these class names for matching nested object fields in this schema.

FIELDS (this page):
----------------------------------------
  po_number: string? [nullable]
    Description: The estimate's po number.

  contract: string? [nullable]
    Description: The `header` of attached contract to the estimate (Note: `header` - [string] the contract's fields concatenated by pattern `{contract_title}`).

  note_to_customer: string? [nullable]
    Description: The estimate's note to customer.

  opportunity_rating: int? [nullable]
    Description: The estimate's opportunity rating.

  opportunity_owner: string? [nullable]
    Description: The `header` of attached opportunity owner to the estimate (Note: `header` - [string] the opportunity owner's fields concatenated by pattern `{first_name} {last_name}` with space as separator).


EXAMPLE CODE PATTERN:
----------------------------------------
// BEGIN_FIELDS
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
// END_FIELDS

================================================================================
EstimateDataObject (parent) page 8/10
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: fields_only
- Return ONLY the property blocks for this page.
- Do NOT include namespace, using statements, class declaration, or closing braces.
- Wrap properties with `// BEGIN_FIELDS` and `// END_FIELDS` markers.

============================================================
SCHEMA: EstimateDataObject (Estimate)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.Estimate
Description: An estimate's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: parent

PAGING:
  Page: 8 of 10
  Fields in this page: 5
  Total fields: 56
  All field names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags

NESTED TYPES: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder
Use these class names for matching nested object fields in this schema.

FIELDS (this page):
----------------------------------------
  agents: Agent[]? [nullable]
    Description: The estimate's agents list.

  custom_fields: CustomField[]? [nullable]
    Description: The estimate's custom fields list.

  pictures: Document[]? [nullable]
    Description: The estimate's pictures list.

  documents: Document[]? [nullable]
    Description: The estimate's documents list.

  equipment: Equipment[]? [nullable]
    Description: The estimate's equipments list.


EXAMPLE CODE PATTERN:
----------------------------------------
// BEGIN_FIELDS
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
// END_FIELDS

================================================================================
EstimateDataObject (parent) page 9/10
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: fields_only
- Return ONLY the property blocks for this page.
- Do NOT include namespace, using statements, class declaration, or closing braces.
- Wrap properties with `// BEGIN_FIELDS` and `// END_FIELDS` markers.

============================================================
SCHEMA: EstimateDataObject (Estimate)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.Estimate
Description: An estimate's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: parent

PAGING:
  Page: 9 of 10
  Fields in this page: 5
  Total fields: 56
  All field names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags

NESTED TYPES: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder
Use these class names for matching nested object fields in this schema.

FIELDS (this page):
----------------------------------------
  techs_assigned: AssignedTech[]? [nullable]
    Description: The estimate's techs assigned list.

  tasks: JobTask[]? [nullable]
    Description: The estimate's tasks list.

  notes: JobNote[]? [nullable]
    Description: The estimate's notes list.

  products: JobProduct[]? [nullable]
    Description: The estimate's products list.

  services: JobService[]? [nullable]
    Description: The estimate's services list.


EXAMPLE CODE PATTERN:
----------------------------------------
// BEGIN_FIELDS
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
// END_FIELDS

================================================================================
EstimateDataObject (parent) page 10/10
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: fields_only
- Return ONLY the property blocks for this page.
- Do NOT include namespace, using statements, class declaration, or closing braces.
- Wrap properties with `// BEGIN_FIELDS` and `// END_FIELDS` markers.

============================================================
SCHEMA: EstimateDataObject (Estimate)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.Estimate
Description: An estimate's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: parent

PAGING:
  Page: 10 of 10
  Fields in this page: 5
  Total fields: 56
  All field names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags

NESTED TYPES: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder
Use these class names for matching nested object fields in this schema.

FIELDS (this page):
----------------------------------------
  other_charges: JobOtherCharge[]? [nullable]
    Description: The estimate's other charges list.

  payments: Payment[]? [nullable]
    Description: The estimate's payments list.

  signatures: JobSignature[]? [nullable]
    Description: The estimate's signatures list.

  printable_work_order: PrintableWorkOrder[]? [nullable]
    Description: The estimate's printable work order list.

  tags: JobTag[]? [nullable]
    Description: The estimate's tags list.


EXAMPLE CODE PATTERN:
----------------------------------------
// BEGIN_FIELDS
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
// END_FIELDS

================================================================================
Agent (nested) page 1/1
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: class_only
- Return ONLY the class declaration for `Agent`.
- Do NOT include namespace or using statements.
- Include only the fields listed for this page.

============================================================
SCHEMA: Agent (Agent)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.Agent
Description: An agent's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: nested

PAGING:
  Page: 1 of 1
  Fields in this page: 3
  Total fields: 3
  All field names: id, first_name, last_name

PARENT CONTEXT:
  Parent Class: EstimateDataObject
  Parent Description: An estimate's schema.
  Parent Field Count: 56
  Parent Field Names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags
  Parent Nested Types: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder

FIELDS (this page):
----------------------------------------
  id: int? [nullable]
    Description: The agent's identifier.

  first_name: string? [nullable]
    Description: The agent's first name.

  last_name: string? [nullable]
    Description: The agent's last name.


EXAMPLE CODE PATTERN:
----------------------------------------
public class Agent
{
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
}

================================================================================
AssignedTech (nested) page 1/1
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: class_only
- Return ONLY the class declaration for `AssignedTech`.
- Do NOT include namespace or using statements.
- Include only the fields listed for this page.

============================================================
SCHEMA: AssignedTech (AssignedTech)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.AssignedTech
Description: An assigned tech's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: nested

PAGING:
  Page: 1 of 1
  Fields in this page: 3
  Total fields: 3
  All field names: id, first_name, last_name

PARENT CONTEXT:
  Parent Class: EstimateDataObject
  Parent Description: An estimate's schema.
  Parent Field Count: 56
  Parent Field Names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags
  Parent Nested Types: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder

FIELDS (this page):
----------------------------------------
  id: int? [nullable]
    Description: The assigned tech's identifier.

  first_name: string? [nullable]
    Description: The assigned tech's first name.

  last_name: string? [nullable]
    Description: The assigned tech's last name.


EXAMPLE CODE PATTERN:
----------------------------------------
public class AssignedTech
{
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
}

================================================================================
CustomField (nested) page 1/2
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: class_only
- Return ONLY the class declaration for `CustomField`.
- Do NOT include namespace or using statements.
- Include only the fields listed for this page.

============================================================
SCHEMA: CustomField (CustomField)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.CustomField
Description: A custom field's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: nested

PAGING:
  Page: 1 of 2
  Fields in this page: 4
  Total fields: 7
  All field names: name, value, type, group, created_at, updated_at, is_required

PARENT CONTEXT:
  Parent Class: EstimateDataObject
  Parent Description: An estimate's schema.
  Parent Field Count: 56
  Parent Field Names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags
  Parent Nested Types: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder

FIELDS (this page):
----------------------------------------
  name: string? [nullable]
    Description: The custom field's name.

  value: object? [nullable]
    Description: The custom field's value.

  type: string? [nullable]
    Description: The custom field's type.

  group: string? [nullable]
    Description: The custom field's group.


EXAMPLE CODE PATTERN:
----------------------------------------
public class CustomField
{
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
}

================================================================================
CustomField (nested) page 2/2
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: fields_only
- Return ONLY the property blocks for this page.
- Do NOT include namespace, using statements, class declaration, or closing braces.
- Wrap properties with `// BEGIN_FIELDS` and `// END_FIELDS` markers.

============================================================
SCHEMA: CustomField (CustomField)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.CustomField
Description: A custom field's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: nested

PAGING:
  Page: 2 of 2
  Fields in this page: 3
  Total fields: 7
  All field names: name, value, type, group, created_at, updated_at, is_required

PARENT CONTEXT:
  Parent Class: EstimateDataObject
  Parent Description: An estimate's schema.
  Parent Field Count: 56
  Parent Field Names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags
  Parent Nested Types: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder

FIELDS (this page):
----------------------------------------
  created_at: DateTime? [nullable]
    Description: The custom field's created date.

  updated_at: DateTime? [nullable]
    Description: The custom field's updated date.

  is_required: bool? [nullable]
    Description: The custom field's is required flag.


EXAMPLE CODE PATTERN:
----------------------------------------
// BEGIN_FIELDS
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
// END_FIELDS

================================================================================
Document (nested) page 1/2
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: class_only
- Return ONLY the class declaration for `Document`.
- Do NOT include namespace or using statements.
- Include only the fields listed for this page.

============================================================
SCHEMA: Document (Document)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.Document
Description: A document's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: nested

PAGING:
  Page: 1 of 2
  Fields in this page: 5
  Total fields: 9
  All field names: name, file_location, doc_type, comment, sort, is_private, created_at, updated_at, customer_doc_id

PARENT CONTEXT:
  Parent Class: EstimateDataObject
  Parent Description: An estimate's schema.
  Parent Field Count: 56
  Parent Field Names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags
  Parent Nested Types: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder

FIELDS (this page):
----------------------------------------
  name: string? [nullable]
    Description: The document's name.

  file_location: string? [nullable]
    Description: The document's file location.

  doc_type: string? [nullable]
    Description: The document's type.

  comment: string? [nullable]
    Description: The document's comment.

  sort: int? [nullable]
    Description: The document's sort.


EXAMPLE CODE PATTERN:
----------------------------------------
public class Document
{
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
}

================================================================================
Document (nested) page 2/2
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: fields_only
- Return ONLY the property blocks for this page.
- Do NOT include namespace, using statements, class declaration, or closing braces.
- Wrap properties with `// BEGIN_FIELDS` and `// END_FIELDS` markers.

============================================================
SCHEMA: Document (Document)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.Document
Description: A document's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: nested

PAGING:
  Page: 2 of 2
  Fields in this page: 4
  Total fields: 9
  All field names: name, file_location, doc_type, comment, sort, is_private, created_at, updated_at, customer_doc_id

PARENT CONTEXT:
  Parent Class: EstimateDataObject
  Parent Description: An estimate's schema.
  Parent Field Count: 56
  Parent Field Names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags
  Parent Nested Types: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder

FIELDS (this page):
----------------------------------------
  is_private: bool? [nullable]
    Description: The document's is private flag.

  created_at: DateTime? [nullable]
    Description: The document's created date.

  updated_at: DateTime? [nullable]
    Description: The document's updated date.

  customer_doc_id: int? [nullable]
    Description: The `id` of attached customer doc to the document (Note: `id` - [integer] the customer doc's identifier).


EXAMPLE CODE PATTERN:
----------------------------------------
// BEGIN_FIELDS
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
// END_FIELDS

================================================================================
Equipment (nested) page 1/4
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: class_only
- Return ONLY the class declaration for `Equipment`.
- Do NOT include namespace or using statements.
- Include only the fields listed for this page.

============================================================
SCHEMA: Equipment (Equipment)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.Equipment
Description: An equipment's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: nested

PAGING:
  Page: 1 of 4
  Fields in this page: 5
  Total fields: 19
  All field names: id, type, make, model, sku, serial_number, location, notes, extended_warranty_provider, is_extended_warranty, extended_warranty_date, warranty_date, install_date, created_at, updated_at, customer_id, customer, customer_location, custom_fields

PARENT CONTEXT:
  Parent Class: EstimateDataObject
  Parent Description: An estimate's schema.
  Parent Field Count: 56
  Parent Field Names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags
  Parent Nested Types: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder

FIELDS (this page):
----------------------------------------
  id: int? [nullable]
    Description: The equipment's identifier.

  type: string? [nullable]
    Description: The equipment's type.

  make: string? [nullable]
    Description: The equipment's make.

  model: string? [nullable]
    Description: The equipment's model.

  sku: string? [nullable]
    Description: The equipment's sku.


EXAMPLE CODE PATTERN:
----------------------------------------
public class Equipment
{
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
}

================================================================================
Equipment (nested) page 2/4
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: fields_only
- Return ONLY the property blocks for this page.
- Do NOT include namespace, using statements, class declaration, or closing braces.
- Wrap properties with `// BEGIN_FIELDS` and `// END_FIELDS` markers.

============================================================
SCHEMA: Equipment (Equipment)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.Equipment
Description: An equipment's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: nested

PAGING:
  Page: 2 of 4
  Fields in this page: 5
  Total fields: 19
  All field names: id, type, make, model, sku, serial_number, location, notes, extended_warranty_provider, is_extended_warranty, extended_warranty_date, warranty_date, install_date, created_at, updated_at, customer_id, customer, customer_location, custom_fields

PARENT CONTEXT:
  Parent Class: EstimateDataObject
  Parent Description: An estimate's schema.
  Parent Field Count: 56
  Parent Field Names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags
  Parent Nested Types: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder

FIELDS (this page):
----------------------------------------
  serial_number: string? [nullable]
    Description: The equipment's serial number.

  location: string? [nullable]
    Description: The equipment's location.

  notes: string? [nullable]
    Description: The equipment's notes.

  extended_warranty_provider: string? [nullable]
    Description: The equipment's extended warranty provider.

  is_extended_warranty: bool? [nullable]
    Description: The equipment's is extended warranty flag.


EXAMPLE CODE PATTERN:
----------------------------------------
// BEGIN_FIELDS
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
// END_FIELDS

================================================================================
Equipment (nested) page 3/4
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: fields_only
- Return ONLY the property blocks for this page.
- Do NOT include namespace, using statements, class declaration, or closing braces.
- Wrap properties with `// BEGIN_FIELDS` and `// END_FIELDS` markers.

============================================================
SCHEMA: Equipment (Equipment)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.Equipment
Description: An equipment's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: nested

PAGING:
  Page: 3 of 4
  Fields in this page: 5
  Total fields: 19
  All field names: id, type, make, model, sku, serial_number, location, notes, extended_warranty_provider, is_extended_warranty, extended_warranty_date, warranty_date, install_date, created_at, updated_at, customer_id, customer, customer_location, custom_fields

PARENT CONTEXT:
  Parent Class: EstimateDataObject
  Parent Description: An estimate's schema.
  Parent Field Count: 56
  Parent Field Names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags
  Parent Nested Types: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder

FIELDS (this page):
----------------------------------------
  extended_warranty_date: DateTime? [nullable]
    Description: The equipment's extended warranty date.

  warranty_date: DateTime? [nullable]
    Description: The equipment's warranty date.

  install_date: DateTime? [nullable]
    Description: The equipment's install date.

  created_at: DateTime? [nullable]
    Description: The equipment's created date.

  updated_at: DateTime? [nullable]
    Description: The equipment's updated date.


EXAMPLE CODE PATTERN:
----------------------------------------
// BEGIN_FIELDS
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
// END_FIELDS

================================================================================
Equipment (nested) page 4/4
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: fields_only
- Return ONLY the property blocks for this page.
- Do NOT include namespace, using statements, class declaration, or closing braces.
- Wrap properties with `// BEGIN_FIELDS` and `// END_FIELDS` markers.

============================================================
SCHEMA: Equipment (Equipment)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.Equipment
Description: An equipment's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: nested

PAGING:
  Page: 4 of 4
  Fields in this page: 4
  Total fields: 19
  All field names: id, type, make, model, sku, serial_number, location, notes, extended_warranty_provider, is_extended_warranty, extended_warranty_date, warranty_date, install_date, created_at, updated_at, customer_id, customer, customer_location, custom_fields

PARENT CONTEXT:
  Parent Class: EstimateDataObject
  Parent Description: An estimate's schema.
  Parent Field Count: 56
  Parent Field Names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags
  Parent Nested Types: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder

FIELDS (this page):
----------------------------------------
  customer_id: int? [nullable]
    Description: The `id` of attached customer to the equipment (Note: `id` - [integer] the customer's identifier).

  customer: string? [nullable]
    Description: The `header` of attached customer to the equipment (Note: `header` - [string] the customer's fields concatenated by pattern `{customer_name}`).

  customer_location: string? [nullable]
    Description: The `header` of attached customer location to the equipment (Note: `header` - [string] the customer location's fields concatenated by pattern `{nickname} {street_1} {city}` with space as separator).

  custom_fields: CustomField[]? [nullable]
    Description: The equipment's custom fields list.


EXAMPLE CODE PATTERN:
----------------------------------------
// BEGIN_FIELDS
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
// END_FIELDS

================================================================================
JobNote (nested) page 1/1
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: class_only
- Return ONLY the class declaration for `JobNote`.
- Do NOT include namespace or using statements.
- Include only the fields listed for this page.

============================================================
SCHEMA: JobNote (JobNote)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.JobNote
Description: A job note's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: nested

PAGING:
  Page: 1 of 1
  Fields in this page: 3
  Total fields: 3
  All field names: notes, created_at, updated_at

PARENT CONTEXT:
  Parent Class: EstimateDataObject
  Parent Description: An estimate's schema.
  Parent Field Count: 56
  Parent Field Names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags
  Parent Nested Types: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder

FIELDS (this page):
----------------------------------------
  notes: string? [nullable]
    Description: The note's text.

  created_at: DateTime? [nullable]
    Description: The note's created date.

  updated_at: DateTime? [nullable]
    Description: The note's updated date.


EXAMPLE CODE PATTERN:
----------------------------------------
public class JobNote
{
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
}

================================================================================
JobOtherCharge (nested) page 1/3
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: class_only
- Return ONLY the class declaration for `JobOtherCharge`.
- Do NOT include namespace or using statements.
- Include only the fields listed for this page.

============================================================
SCHEMA: JobOtherCharge (JobOtherCharge)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.JobOtherCharge
Description: A job other charge's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: nested

PAGING:
  Page: 1 of 3
  Fields in this page: 6
  Total fields: 16
  All field names: name, rate, total, charge_index, parent_index, is_percentage, is_discount, created_at, updated_at, other_charge, applies_to, service_list_id, other_charge_id, pattern_row_id, qbo_class_id, qbd_class_id

PARENT CONTEXT:
  Parent Class: EstimateDataObject
  Parent Description: An estimate's schema.
  Parent Field Count: 56
  Parent Field Names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags
  Parent Nested Types: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder

FIELDS (this page):
----------------------------------------
  name: string? [nullable]
    Description: The other charge's name.

  rate: double? [nullable]
    Description: The other charge's rate.

  total: double? [nullable]
    Description: The other charge's total.

  charge_index: int? [nullable]
    Description: The other charge's index.

  parent_index: int? [nullable]
    Description: The other charge's parent index.

  is_percentage: bool? [nullable]
    Description: The other charge's is percentage flag.


EXAMPLE CODE PATTERN:
----------------------------------------
public class JobOtherCharge
{
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
}

================================================================================
JobOtherCharge (nested) page 2/3
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: fields_only
- Return ONLY the property blocks for this page.
- Do NOT include namespace, using statements, class declaration, or closing braces.
- Wrap properties with `// BEGIN_FIELDS` and `// END_FIELDS` markers.

============================================================
SCHEMA: JobOtherCharge (JobOtherCharge)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.JobOtherCharge
Description: A job other charge's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: nested

PAGING:
  Page: 2 of 3
  Fields in this page: 5
  Total fields: 16
  All field names: name, rate, total, charge_index, parent_index, is_percentage, is_discount, created_at, updated_at, other_charge, applies_to, service_list_id, other_charge_id, pattern_row_id, qbo_class_id, qbd_class_id

PARENT CONTEXT:
  Parent Class: EstimateDataObject
  Parent Description: An estimate's schema.
  Parent Field Count: 56
  Parent Field Names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags
  Parent Nested Types: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder

FIELDS (this page):
----------------------------------------
  is_discount: bool? [nullable]
    Description: The other charge's is discount flag.

  created_at: DateTime? [nullable]
    Description: The other charge's created date.

  updated_at: DateTime? [nullable]
    Description: The other charge's updated date.

  other_charge: string? [nullable]
    Description: The `header` of attached other charge to the other charge (Note: `header` - [string] the other charge's fields concatenated by pattern `{short_name}`).

  applies_to: string? [nullable]
    Description: The other charge's applies to.


EXAMPLE CODE PATTERN:
----------------------------------------
// BEGIN_FIELDS
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
// END_FIELDS

================================================================================
JobOtherCharge (nested) page 3/3
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: fields_only
- Return ONLY the property blocks for this page.
- Do NOT include namespace, using statements, class declaration, or closing braces.
- Wrap properties with `// BEGIN_FIELDS` and `// END_FIELDS` markers.

============================================================
SCHEMA: JobOtherCharge (JobOtherCharge)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.JobOtherCharge
Description: A job other charge's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: nested

PAGING:
  Page: 3 of 3
  Fields in this page: 5
  Total fields: 16
  All field names: name, rate, total, charge_index, parent_index, is_percentage, is_discount, created_at, updated_at, other_charge, applies_to, service_list_id, other_charge_id, pattern_row_id, qbo_class_id, qbd_class_id

PARENT CONTEXT:
  Parent Class: EstimateDataObject
  Parent Description: An estimate's schema.
  Parent Field Count: 56
  Parent Field Names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags
  Parent Nested Types: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder

FIELDS (this page):
----------------------------------------
  service_list_id: int? [nullable]
    Description: The `id` of attached service list to the other charge (Note: `id` - [integer] the service list's identifier).

  other_charge_id: int? [nullable]
    Description: The `id` of attached other charge to the other charge (Note: `id` - [integer] the other charge's identifier).

  pattern_row_id: int? [nullable]
    Description: The `id` of attached pattern row to the other charge (Note: `id` - [integer] the pattern row's identifier).

  qbo_class_id: int? [nullable]
    Description: The `id` of attached qbo class to the other charge (Note: `id` - [integer] the qbo class'es identifier).

  qbd_class_id: int? [nullable]
    Description: The `id` of attached qbd class to the other charge (Note: `id` - [integer] the qbd class'es identifier).


EXAMPLE CODE PATTERN:
----------------------------------------
// BEGIN_FIELDS
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
// END_FIELDS

================================================================================
JobProduct (nested) page 1/4
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: class_only
- Return ONLY the class declaration for `JobProduct`.
- Do NOT include namespace or using statements.
- Include only the fields listed for this page.

============================================================
SCHEMA: JobProduct (JobProduct)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.JobProduct
Description: A job product's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: nested

PAGING:
  Page: 1 of 4
  Fields in this page: 5
  Total fields: 19
  All field names: name, description, multiplier, rate, total, cost, actual_cost, item_index, parent_index, created_at, updated_at, is_show_rate_items, tax, product, product_list_id, warehouse_id, pattern_row_id, qbo_class_id, qbd_class_id

PARENT CONTEXT:
  Parent Class: EstimateDataObject
  Parent Description: An estimate's schema.
  Parent Field Count: 56
  Parent Field Names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags
  Parent Nested Types: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder

FIELDS (this page):
----------------------------------------
  name: string? [nullable]
    Description: The product's name.

  description: string? [nullable]
    Description: The product's description.

  multiplier: int? [nullable]
    Description: The product's quantity.

  rate: double? [nullable]
    Description: The product's rate.

  total: double? [nullable]
    Description: The product's total.


EXAMPLE CODE PATTERN:
----------------------------------------
public class JobProduct
{
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
}

================================================================================
JobProduct (nested) page 2/4
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: fields_only
- Return ONLY the property blocks for this page.
- Do NOT include namespace, using statements, class declaration, or closing braces.
- Wrap properties with `// BEGIN_FIELDS` and `// END_FIELDS` markers.

============================================================
SCHEMA: JobProduct (JobProduct)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.JobProduct
Description: A job product's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: nested

PAGING:
  Page: 2 of 4
  Fields in this page: 5
  Total fields: 19
  All field names: name, description, multiplier, rate, total, cost, actual_cost, item_index, parent_index, created_at, updated_at, is_show_rate_items, tax, product, product_list_id, warehouse_id, pattern_row_id, qbo_class_id, qbd_class_id

PARENT CONTEXT:
  Parent Class: EstimateDataObject
  Parent Description: An estimate's schema.
  Parent Field Count: 56
  Parent Field Names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags
  Parent Nested Types: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder

FIELDS (this page):
----------------------------------------
  cost: double? [nullable]
    Description: The product's cost.

  actual_cost: double? [nullable]
    Description: The product's actual cost.

  item_index: int? [nullable]
    Description: The product's item index.

  parent_index: int? [nullable]
    Description: The product's parent index.

  created_at: DateTime? [nullable]
    Description: The product's created date.


EXAMPLE CODE PATTERN:
----------------------------------------
// BEGIN_FIELDS
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
// END_FIELDS

================================================================================
JobProduct (nested) page 3/4
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: fields_only
- Return ONLY the property blocks for this page.
- Do NOT include namespace, using statements, class declaration, or closing braces.
- Wrap properties with `// BEGIN_FIELDS` and `// END_FIELDS` markers.

============================================================
SCHEMA: JobProduct (JobProduct)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.JobProduct
Description: A job product's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: nested

PAGING:
  Page: 3 of 4
  Fields in this page: 5
  Total fields: 19
  All field names: name, description, multiplier, rate, total, cost, actual_cost, item_index, parent_index, created_at, updated_at, is_show_rate_items, tax, product, product_list_id, warehouse_id, pattern_row_id, qbo_class_id, qbd_class_id

PARENT CONTEXT:
  Parent Class: EstimateDataObject
  Parent Description: An estimate's schema.
  Parent Field Count: 56
  Parent Field Names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags
  Parent Nested Types: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder

FIELDS (this page):
----------------------------------------
  updated_at: DateTime? [nullable]
    Description: The product's updated date.

  is_show_rate_items: bool? [nullable]
    Description: The product's is show rate items flag.

  tax: string? [nullable]
    Description: The `header` of attached tax to the product (Note: `header` - [string] the tax'es fields concatenated by pattern `{short_name}`).

  product: string? [nullable]
    Description: The `header` of attached product to the product (Note: `header` - [string] the product's fields concatenated by pattern `{make}`).

  product_list_id: int? [nullable]
    Description: The `id` of attached product list to the product (Note: `id` - [integer] the product list's identifier).


EXAMPLE CODE PATTERN:
----------------------------------------
// BEGIN_FIELDS
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
// END_FIELDS

================================================================================
JobProduct (nested) page 4/4
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: fields_only
- Return ONLY the property blocks for this page.
- Do NOT include namespace, using statements, class declaration, or closing braces.
- Wrap properties with `// BEGIN_FIELDS` and `// END_FIELDS` markers.

============================================================
SCHEMA: JobProduct (JobProduct)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.JobProduct
Description: A job product's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: nested

PAGING:
  Page: 4 of 4
  Fields in this page: 4
  Total fields: 19
  All field names: name, description, multiplier, rate, total, cost, actual_cost, item_index, parent_index, created_at, updated_at, is_show_rate_items, tax, product, product_list_id, warehouse_id, pattern_row_id, qbo_class_id, qbd_class_id

PARENT CONTEXT:
  Parent Class: EstimateDataObject
  Parent Description: An estimate's schema.
  Parent Field Count: 56
  Parent Field Names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags
  Parent Nested Types: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder

FIELDS (this page):
----------------------------------------
  warehouse_id: int? [nullable]
    Description: The `id` of attached warehouse to the product (Note: `id` - [integer] the warehouse's identifier).

  pattern_row_id: int? [nullable]
    Description: The `id` of attached pattern row to the product (Note: `id` - [integer] the pattern row's identifier).

  qbo_class_id: int? [nullable]
    Description: The `id` of attached qbo class to the product (Note: `id` - [integer] the qbo class'es identifier).

  qbd_class_id: int? [nullable]
    Description: The `id` of attached qbd class to the product (Note: `id` - [integer] the qbd class'es identifier).


EXAMPLE CODE PATTERN:
----------------------------------------
// BEGIN_FIELDS
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
// END_FIELDS

================================================================================
JobService (nested) page 1/4
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: class_only
- Return ONLY the class declaration for `JobService`.
- Do NOT include namespace or using statements.
- Include only the fields listed for this page.

============================================================
SCHEMA: JobService (JobService)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.JobService
Description: A job service's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: nested

PAGING:
  Page: 1 of 4
  Fields in this page: 5
  Total fields: 19
  All field names: name, description, multiplier, rate, total, cost, actual_cost, item_index, parent_index, created_at, updated_at, is_show_rate_items, tax, service, service_list_id, service_rate_id, pattern_row_id, qbo_class_id, qbd_class_id

PARENT CONTEXT:
  Parent Class: EstimateDataObject
  Parent Description: An estimate's schema.
  Parent Field Count: 56
  Parent Field Names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags
  Parent Nested Types: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder

FIELDS (this page):
----------------------------------------
  name: string? [nullable]
    Description: The service's name.

  description: string? [nullable]
    Description: The service's description.

  multiplier: int? [nullable]
    Description: The service's quantity.

  rate: double? [nullable]
    Description: The service's rate.

  total: double? [nullable]
    Description: The service's total.


EXAMPLE CODE PATTERN:
----------------------------------------
public class JobService
{
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
}

================================================================================
JobService (nested) page 2/4
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: fields_only
- Return ONLY the property blocks for this page.
- Do NOT include namespace, using statements, class declaration, or closing braces.
- Wrap properties with `// BEGIN_FIELDS` and `// END_FIELDS` markers.

============================================================
SCHEMA: JobService (JobService)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.JobService
Description: A job service's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: nested

PAGING:
  Page: 2 of 4
  Fields in this page: 5
  Total fields: 19
  All field names: name, description, multiplier, rate, total, cost, actual_cost, item_index, parent_index, created_at, updated_at, is_show_rate_items, tax, service, service_list_id, service_rate_id, pattern_row_id, qbo_class_id, qbd_class_id

PARENT CONTEXT:
  Parent Class: EstimateDataObject
  Parent Description: An estimate's schema.
  Parent Field Count: 56
  Parent Field Names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags
  Parent Nested Types: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder

FIELDS (this page):
----------------------------------------
  cost: double? [nullable]
    Description: The service's cost.

  actual_cost: double? [nullable]
    Description: The service's actual cost.

  item_index: int? [nullable]
    Description: The service's item index.

  parent_index: int? [nullable]
    Description: The service's parent index.

  created_at: DateTime? [nullable]
    Description: The service's created date.


EXAMPLE CODE PATTERN:
----------------------------------------
// BEGIN_FIELDS
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
// END_FIELDS

================================================================================
JobService (nested) page 3/4
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: fields_only
- Return ONLY the property blocks for this page.
- Do NOT include namespace, using statements, class declaration, or closing braces.
- Wrap properties with `// BEGIN_FIELDS` and `// END_FIELDS` markers.

============================================================
SCHEMA: JobService (JobService)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.JobService
Description: A job service's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: nested

PAGING:
  Page: 3 of 4
  Fields in this page: 5
  Total fields: 19
  All field names: name, description, multiplier, rate, total, cost, actual_cost, item_index, parent_index, created_at, updated_at, is_show_rate_items, tax, service, service_list_id, service_rate_id, pattern_row_id, qbo_class_id, qbd_class_id

PARENT CONTEXT:
  Parent Class: EstimateDataObject
  Parent Description: An estimate's schema.
  Parent Field Count: 56
  Parent Field Names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags
  Parent Nested Types: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder

FIELDS (this page):
----------------------------------------
  updated_at: DateTime? [nullable]
    Description: The service's updated date.

  is_show_rate_items: bool? [nullable]
    Description: The service's is show rate items flag.

  tax: string? [nullable]
    Description: The `header` of attached tax to the service (Note: `header` - [string] the tax'es fields concatenated by pattern `{short_name}`).

  service: string? [nullable]
    Description: The `header` of attached service to the service (Note: `header` - [string] the service's fields concatenated by pattern `{short_description}`).

  service_list_id: int? [nullable]
    Description: The `id` of attached service list to the service (Note: `id` - [integer] the service list's identifier).


EXAMPLE CODE PATTERN:
----------------------------------------
// BEGIN_FIELDS
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
// END_FIELDS

================================================================================
JobService (nested) page 4/4
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: fields_only
- Return ONLY the property blocks for this page.
- Do NOT include namespace, using statements, class declaration, or closing braces.
- Wrap properties with `// BEGIN_FIELDS` and `// END_FIELDS` markers.

============================================================
SCHEMA: JobService (JobService)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.JobService
Description: A job service's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: nested

PAGING:
  Page: 4 of 4
  Fields in this page: 4
  Total fields: 19
  All field names: name, description, multiplier, rate, total, cost, actual_cost, item_index, parent_index, created_at, updated_at, is_show_rate_items, tax, service, service_list_id, service_rate_id, pattern_row_id, qbo_class_id, qbd_class_id

PARENT CONTEXT:
  Parent Class: EstimateDataObject
  Parent Description: An estimate's schema.
  Parent Field Count: 56
  Parent Field Names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags
  Parent Nested Types: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder

FIELDS (this page):
----------------------------------------
  service_rate_id: int? [nullable]
    Description: The `id` of attached service rate to the service (Note: `id` - [integer] the service rate's identifier).

  pattern_row_id: int? [nullable]
    Description: The `id` of attached pattern row to the service (Note: `id` - [integer] the pattern row's identifier).

  qbo_class_id: int? [nullable]
    Description: The `id` of attached qbo class to the service (Note: `id` - [integer] the qbo class'es identifier).

  qbd_class_id: int? [nullable]
    Description: The `id` of attached qbd class to the service (Note: `id` - [integer] the qbd class'es identifier).


EXAMPLE CODE PATTERN:
----------------------------------------
// BEGIN_FIELDS
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
// END_FIELDS

================================================================================
JobSignature (nested) page 1/1
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: class_only
- Return ONLY the class declaration for `JobSignature`.
- Do NOT include namespace or using statements.
- Include only the fields listed for this page.

============================================================
SCHEMA: JobSignature (JobSignature)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.JobSignature
Description: A job signature's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: nested

PAGING:
  Page: 1 of 1
  Fields in this page: 4
  Total fields: 4
  All field names: type, file_name, created_at, updated_at

PARENT CONTEXT:
  Parent Class: EstimateDataObject
  Parent Description: An estimate's schema.
  Parent Field Count: 56
  Parent Field Names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags
  Parent Nested Types: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder

FIELDS (this page):
----------------------------------------
  type: string? [nullable]
    Description: The signature's type.

  file_name: string? [nullable]
    Description: The signature's file name.

  created_at: DateTime? [nullable]
    Description: The signature's created date.

  updated_at: DateTime? [nullable]
    Description: The signature's updated date.


EXAMPLE CODE PATTERN:
----------------------------------------
public class JobSignature
{
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
}

================================================================================
JobTag (nested) page 1/1
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: class_only
- Return ONLY the class declaration for `JobTag`.
- Do NOT include namespace or using statements.
- Include only the fields listed for this page.

============================================================
SCHEMA: JobTag (JobTag)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.JobTag
Description: A job tag's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: nested

PAGING:
  Page: 1 of 1
  Fields in this page: 3
  Total fields: 3
  All field names: tag, created_at, updated_at

PARENT CONTEXT:
  Parent Class: EstimateDataObject
  Parent Description: An estimate's schema.
  Parent Field Count: 56
  Parent Field Names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags
  Parent Nested Types: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder

FIELDS (this page):
----------------------------------------
  tag: string? [nullable]
    Description: The tag's unique tag.

  created_at: DateTime? [nullable]
    Description: The tag's created date.

  updated_at: DateTime? [nullable]
    Description: The tag's updated date.


EXAMPLE CODE PATTERN:
----------------------------------------
public class JobTag
{
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
}

================================================================================
JobTask (nested) page 1/2
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: class_only
- Return ONLY the class declaration for `JobTask`.
- Do NOT include namespace or using statements.
- Include only the fields listed for this page.

============================================================
SCHEMA: JobTask (JobTask)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.JobTask
Description: A job task's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: nested

PAGING:
  Page: 1 of 2
  Fields in this page: 4
  Total fields: 8
  All field names: type, description, start_time, start_date, end_date, is_completed, created_at, updated_at

PARENT CONTEXT:
  Parent Class: EstimateDataObject
  Parent Description: An estimate's schema.
  Parent Field Count: 56
  Parent Field Names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags
  Parent Nested Types: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder

FIELDS (this page):
----------------------------------------
  type: string? [nullable]
    Description: The task's type.

  description: string? [nullable]
    Description: The task's description.

  start_time: string? [nullable]
    Description: The task's start time.

  start_date: DateTime? [nullable]
    Description: The task's start date.


EXAMPLE CODE PATTERN:
----------------------------------------
public class JobTask
{
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
}

================================================================================
JobTask (nested) page 2/2
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: fields_only
- Return ONLY the property blocks for this page.
- Do NOT include namespace, using statements, class declaration, or closing braces.
- Wrap properties with `// BEGIN_FIELDS` and `// END_FIELDS` markers.

============================================================
SCHEMA: JobTask (JobTask)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.JobTask
Description: A job task's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: nested

PAGING:
  Page: 2 of 2
  Fields in this page: 4
  Total fields: 8
  All field names: type, description, start_time, start_date, end_date, is_completed, created_at, updated_at

PARENT CONTEXT:
  Parent Class: EstimateDataObject
  Parent Description: An estimate's schema.
  Parent Field Count: 56
  Parent Field Names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags
  Parent Nested Types: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder

FIELDS (this page):
----------------------------------------
  end_date: DateTime? [nullable]
    Description: The task's end date.

  is_completed: bool? [nullable]
    Description: The task's is completed flag.

  created_at: DateTime? [nullable]
    Description: The task's created date.

  updated_at: DateTime? [nullable]
    Description: The task's updated date.


EXAMPLE CODE PATTERN:
----------------------------------------
// BEGIN_FIELDS
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
// END_FIELDS

================================================================================
Payment (nested) page 1/5
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: class_only
- Return ONLY the class declaration for `Payment`.
- Do NOT include namespace or using statements.
- Include only the fields listed for this page.

============================================================
SCHEMA: Payment (Payment)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.Payment
Description: A payment's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: nested

PAGING:
  Page: 1 of 5
  Fields in this page: 5
  Total fields: 25
  All field names: transaction_type, transaction_token, transaction_id, payment_transaction_id, original_transaction_id, apply_to, amount, memo, authorization_code, bill_to_street_address, bill_to_postal_code, bill_to_country, reference_number, is_resync_qbo, created_at, updated_at, received_on, qbo_synced_date, qbo_id, qbd_id, customer, type, invoice_id, gateway_id, receipt_id

PARENT CONTEXT:
  Parent Class: EstimateDataObject
  Parent Description: An estimate's schema.
  Parent Field Count: 56
  Parent Field Names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags
  Parent Nested Types: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder

FIELDS (this page):
----------------------------------------
  transaction_type: string? [nullable]
    Description: The payment's transaction type.

  transaction_token: string? [nullable]
    Description: The payment's transaction token.

  transaction_id: string? [nullable]
    Description: The `id` of attached transaction to the payment (Note: `id` - [integer] the transaction's identifier).

  payment_transaction_id: int? [nullable]
    Description: The `id` of attached payment transaction to the payment (Note: `id` - [integer] the payment transaction's identifier).

  original_transaction_id: int? [nullable]
    Description: The `id` of attached original transaction to the payment (Note: `id` - [integer] the original transaction's identifier).


EXAMPLE CODE PATTERN:
----------------------------------------
public class Payment
{
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
}

================================================================================
Payment (nested) page 2/5
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: fields_only
- Return ONLY the property blocks for this page.
- Do NOT include namespace, using statements, class declaration, or closing braces.
- Wrap properties with `// BEGIN_FIELDS` and `// END_FIELDS` markers.

============================================================
SCHEMA: Payment (Payment)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.Payment
Description: A payment's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: nested

PAGING:
  Page: 2 of 5
  Fields in this page: 5
  Total fields: 25
  All field names: transaction_type, transaction_token, transaction_id, payment_transaction_id, original_transaction_id, apply_to, amount, memo, authorization_code, bill_to_street_address, bill_to_postal_code, bill_to_country, reference_number, is_resync_qbo, created_at, updated_at, received_on, qbo_synced_date, qbo_id, qbd_id, customer, type, invoice_id, gateway_id, receipt_id

PARENT CONTEXT:
  Parent Class: EstimateDataObject
  Parent Description: An estimate's schema.
  Parent Field Count: 56
  Parent Field Names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags
  Parent Nested Types: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder

FIELDS (this page):
----------------------------------------
  apply_to: string? [nullable]
    Description: The payment's apply to.

  amount: double? [nullable]
    Description: The payment's amount.

  memo: string? [nullable]
    Description: The payment's memo.

  authorization_code: string? [nullable]
    Description: The payment's authorization code.

  bill_to_street_address: string? [nullable]
    Description: The payment's bill to street address.


EXAMPLE CODE PATTERN:
----------------------------------------
// BEGIN_FIELDS
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
// END_FIELDS

================================================================================
Payment (nested) page 3/5
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: fields_only
- Return ONLY the property blocks for this page.
- Do NOT include namespace, using statements, class declaration, or closing braces.
- Wrap properties with `// BEGIN_FIELDS` and `// END_FIELDS` markers.

============================================================
SCHEMA: Payment (Payment)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.Payment
Description: A payment's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: nested

PAGING:
  Page: 3 of 5
  Fields in this page: 5
  Total fields: 25
  All field names: transaction_type, transaction_token, transaction_id, payment_transaction_id, original_transaction_id, apply_to, amount, memo, authorization_code, bill_to_street_address, bill_to_postal_code, bill_to_country, reference_number, is_resync_qbo, created_at, updated_at, received_on, qbo_synced_date, qbo_id, qbd_id, customer, type, invoice_id, gateway_id, receipt_id

PARENT CONTEXT:
  Parent Class: EstimateDataObject
  Parent Description: An estimate's schema.
  Parent Field Count: 56
  Parent Field Names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags
  Parent Nested Types: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder

FIELDS (this page):
----------------------------------------
  bill_to_postal_code: string? [nullable]
    Description: The payment's bill to postal code.

  bill_to_country: string? [nullable]
    Description: The payment's bill to country.

  reference_number: string? [nullable]
    Description: The payment's reference number.

  is_resync_qbo: bool? [nullable]
    Description: The payment's is resync qbo flag.

  created_at: DateTime? [nullable]
    Description: The payment's created date.


EXAMPLE CODE PATTERN:
----------------------------------------
// BEGIN_FIELDS
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
// END_FIELDS

================================================================================
Payment (nested) page 4/5
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: fields_only
- Return ONLY the property blocks for this page.
- Do NOT include namespace, using statements, class declaration, or closing braces.
- Wrap properties with `// BEGIN_FIELDS` and `// END_FIELDS` markers.

============================================================
SCHEMA: Payment (Payment)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.Payment
Description: A payment's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: nested

PAGING:
  Page: 4 of 5
  Fields in this page: 5
  Total fields: 25
  All field names: transaction_type, transaction_token, transaction_id, payment_transaction_id, original_transaction_id, apply_to, amount, memo, authorization_code, bill_to_street_address, bill_to_postal_code, bill_to_country, reference_number, is_resync_qbo, created_at, updated_at, received_on, qbo_synced_date, qbo_id, qbd_id, customer, type, invoice_id, gateway_id, receipt_id

PARENT CONTEXT:
  Parent Class: EstimateDataObject
  Parent Description: An estimate's schema.
  Parent Field Count: 56
  Parent Field Names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags
  Parent Nested Types: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder

FIELDS (this page):
----------------------------------------
  updated_at: DateTime? [nullable]
    Description: The payment's updated date.

  received_on: DateTime? [nullable]
    Description: The payment's received date.

  qbo_synced_date: DateTime? [nullable]
    Description: The payment's qbo synced date.

  qbo_id: int? [nullable]
    Description: The `id` of attached qbo class to the payment (Note: `id` - [integer] the qbo class'es identifier).

  qbd_id: string? [nullable]
    Description: The `id` of attached qbd class to the payment (Note: `id` - [integer] the qbd class'es identifier).


EXAMPLE CODE PATTERN:
----------------------------------------
// BEGIN_FIELDS
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
// END_FIELDS

================================================================================
Payment (nested) page 5/5
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: fields_only
- Return ONLY the property blocks for this page.
- Do NOT include namespace, using statements, class declaration, or closing braces.
- Wrap properties with `// BEGIN_FIELDS` and `// END_FIELDS` markers.

============================================================
SCHEMA: Payment (Payment)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.Payment
Description: A payment's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: nested

PAGING:
  Page: 5 of 5
  Fields in this page: 5
  Total fields: 25
  All field names: transaction_type, transaction_token, transaction_id, payment_transaction_id, original_transaction_id, apply_to, amount, memo, authorization_code, bill_to_street_address, bill_to_postal_code, bill_to_country, reference_number, is_resync_qbo, created_at, updated_at, received_on, qbo_synced_date, qbo_id, qbd_id, customer, type, invoice_id, gateway_id, receipt_id

PARENT CONTEXT:
  Parent Class: EstimateDataObject
  Parent Description: An estimate's schema.
  Parent Field Count: 56
  Parent Field Names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags
  Parent Nested Types: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder

FIELDS (this page):
----------------------------------------
  customer: string? [nullable]
    Description: The `header` of attached customer to the payment (Note: `header` - [string] the customer's fields concatenated by pattern `{customer_name}`).

  type: string? [nullable]
    Description: The `header` of attached customer payment method to the payment (Note: `header` - [string] the customer payment method's fields concatenated by pattern `{cc_type} {first_four} {last_four}` with space as separator).
If customer payment method does not attached - it returns the `header` of attached payment type to the job payment (Note: `header` - [string] the payment type's fields concatenated by pattern `{name}`).

  invoice_id: int? [nullable]
    Description: The `id` of attached invoice to the payment (Note: `id` - [integer] the invoice's identifier).

  gateway_id: int? [nullable]
    Description: The `id` of attached gateway to the payment (Note: `id` - [integer] the gateway's identifier).

  receipt_id: string? [nullable]
    Description: The `id` of attached receipt to the payment (Note: `id` - [integer] the receipt's identifier).


EXAMPLE CODE PATTERN:
----------------------------------------
// BEGIN_FIELDS
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
// END_FIELDS

================================================================================
PrintableWorkOrder (nested) page 1/1
================================================================================
Generate a C# Trimble XChange DataObject class based on the provided schema information.

REQUIREMENTS:
1. Use the exact JSON property names from the schema with [JsonPropertyName] attributes
2. Convert JSON field names to PascalCase for C# property names
3. Add [Description] attributes using the field descriptions from the schema
4. Mark required fields with [Required] attribute and use 'required' keyword
5. Mark nullable fields with [Nullable(true)] attribute and use nullable type (e.g., string?)
6. Use 'init' accessors for immutable data objects: { get; init; }
7. Include a [PrimaryKey] attribute ONLY on the main DataObject class (the one ending in 'DataObject'). Do NOT add [PrimaryKey] to nested/helper types. Use the primary_key_field from the schema if provided.
8. If primary_key_needs_selection is true, YOU must select an appropriate primary key field using these criteria in order: (a) prefer fields with 'id' or 'key' in the name, (b) prefer required/non-nullable fields, (c) prefer string or integer types. Add a comment after the PrimaryKey attribute: // [REVIEW: PrimaryKey auto-selected]
9. Primary key fields must be required and non-nullable. Do NOT mark primary key fields with [Nullable(true)] or nullable types.
10. If a field provides Enum values, use a C# enum type for that field and define the enum in the same file. Add [JsonConverter(typeof(JsonStringEnumConverter))] to the enum and apply [JsonStringEnumMemberName("<value>")] to each enum member so serialized values match the schema.
11. If a field has type_unresolved=true, the type could not be resolved from the IR. Use 'object' or 'object?' as the type and add a comment: // [REVIEW: Type unresolved from IR]
12. Add XML summary comments for the class
13. Use appropriate C# types:
    - string for text
    - int/long for integers
    - double/decimal for numbers
    - bool for booleans
    - DateTime for datetime fields
    - DateOnly for date-only fields

DO NOT INCLUDE:
- namespace declarations
- using directives
Start directly with the XML summary comment for the class.

OUTPUT:
Return ONLY the C# class definition, no explanations or markdown.

OUTPUT MODE: class_only
- Return ONLY the class declaration for `PrintableWorkOrder`.
- Do NOT include namespace or using statements.
- Include only the fields listed for this page.

============================================================
SCHEMA: PrintableWorkOrder (PrintableWorkOrder)
============================================================
API Name: servicefusion
Schema ID: schema:types/typ.PrintableWorkOrder
Description: A printable work order's schema.
Namespace: Connector.servicefusion.v1.Estimate
Role: nested

PAGING:
  Page: 1 of 1
  Fields in this page: 2
  Total fields: 2
  All field names: name, url

PARENT CONTEXT:
  Parent Class: EstimateDataObject
  Parent Description: An estimate's schema.
  Parent Field Count: 56
  Parent Field Names: id, number, description, tech_notes, customer_payment_terms, payment_status, taxes_fees_total, total, due_total, cost_total, duration, time_frame_promised_start, time_frame_promised_end, start_date, created_at, updated_at, customer_id, customer_name, parent_customer, status, sub_status, contact_first_name, contact_last_name, street_1, street_2, city, state_prov, postal_code, location_name, is_gated, gate_instructions, category, source, payment_type, project, phase, po_number, contract, note_to_customer, opportunity_rating, opportunity_owner, agents, custom_fields, pictures, documents, equipment, techs_assigned, tasks, notes, products, services, other_charges, payments, signatures, printable_work_order, tags
  Parent Nested Types: Agent, AssignedTech, CustomField, Document, Equipment, JobNote, JobOtherCharge, JobProduct, JobService, JobSignature, JobTag, JobTask, Payment, PrintableWorkOrder

FIELDS (this page):
----------------------------------------
  name: string? [nullable]
    Description: The printable work order's name.

  url: string? [nullable]
    Description: The printable work order's url.


EXAMPLE CODE PATTERN:
----------------------------------------
public class PrintableWorkOrder
{
    [JsonPropertyName("example_field")]
    [Description("Example field")]
    [Nullable(true)]
    public string? ExampleField { get; init; }
}
